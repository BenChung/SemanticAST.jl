<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SemanticAST · SemanticAST</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SemanticAST</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SemanticAST</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Use"><span>Use</span></a></li><li><a class="tocitem" href="#Limitation:-Macros"><span>Limitation: Macros</span></a></li><li><a class="tocitem" href="#Limitation:-Quoting"><span>Limitation: Quoting</span></a></li><li class="toplevel"><a class="tocitem" href="#State"><span>State</span></a></li></ul></li><li><a class="tocitem" href="interface/">Public interface</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SemanticAST</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SemanticAST</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BenChung/SemanticAST.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SemanticAST"><a class="docs-heading-anchor" href="#SemanticAST">SemanticAST</a><a id="SemanticAST-1"></a><a class="docs-heading-anchor-permalink" href="#SemanticAST" title="Permalink"></a></h1><p>SemanticAST.jl aims to provide a unified view of Julia&#39;s AST by reproducing much of the logic that the <a href="https://docs.julialang.org/en/v1/devdocs/eval/#dev-parsing">lowering</a> phase does. Many of the more structural errors that Julia produces (for example how a toplevel <code>::Int</code> declaration begets <code>syntax: invalid &quot;::&quot; syntax</code>) are not actually produced by the parser but instead by a later lowering phase. In effect, lowering (in conjunction with macro expansion) defines all of the Julia AST forms that can be successfully compiled to executable runtime code. If it can be lowered, it will at least <em>attempt</em> to execute.</p><p><code>Expr</code> ASTs are notoriously annoying to deal with to the point that packages like <a href="https://github.com/invenia/ExprTools.jl">ExprTools</a> are widely used to analyze what&#39;s actually there. <code>Expr</code>s will come in all sorts of wild and wonderful forms and having a library to deal with all of the possible cases is a great help. However, ExprTools only goes so far: it solely provides a consistent representation of function definitions. SemanticAST aims to go further.</p><p>SemanticAST aims to extend this sort of &quot;rationalization&quot; to all of Julia&#39;s syntax; it provides a single set of AST definitions that explicitly declare every parameter and are descriptive about what their fields mean. Moreover, SemanticAST&#39;s types try to be complete –- that is, you can use the type of a field in a SemanticAST struct to determine precisely what any possible member might be. Additionally, by sitting on top of JuliaSyntax, SemanticAST provides detailed source location information both in the output AST and in the lowering-equivalent error messages that SemanticAST produces The objective, then, is to eliminate the surprise inherent to working with Julia&#39;s AST forms, allowing easier development of static analysis tooling for Julia.</p><p>The implementation strategy for SemanticAST is to bring together lowering, parts of toplevel evaluation, and parts of the Julia runtime itself to identify as many errors as early as possible. Ideally, SemanticAST will accept any program that is &quot;runnable&quot; by Julia, even if it might encounter a dynamic error. Errors produced by SemanticAST aim to parallel errors produced by Julia itself as it goes to compile a given <code>Expr</code> to IR, as well as parts of evaluation of that IR.</p><ul><li><a href="#SemanticAST">SemanticAST</a></li><li><a href="#Use">Use</a></li><li class="no-marker"><ul><li><a href="#Limitation:-Macros">Limitation: Macros</a></li><li><a href="#Limitation:-Quoting">Limitation: Quoting</a></li></ul></li><li><a href="#State">State</a></li></ul><h1 id="Use"><a class="docs-heading-anchor" href="#Use">Use</a><a id="Use-1"></a><a class="docs-heading-anchor-permalink" href="#Use" title="Permalink"></a></h1><p>SemanticAST&#39;s entry points are through the <code>expand_forms</code> and <code>expand_toplevel</code> functions; given a <code>JuliaSyntax.SyntaxNode</code> and a <code>ExpandCtx</code> they will attempt to unpack a <code>SyntaxNode</code> into a <code>SemanticAST.Expression</code> and <code>SemanticAST.ToplevelStmts</code>, respectively. Note that SemanticAST AST forms all contain a <code>location</code> field that&#39;s implicitly inserted by the <code>@ast_node</code> and <code>@ast_data</code> macros that is of type <code>SemanticAST.SourcePosition</code>.</p><p>As an example, suppose we wanted to analyze the program <code>hello_world.jl</code> that looked like</p><pre><code class="nohighlight hljs">function hello_world()
    println(&quot;hello world!&quot;)
end</code></pre><p>the complete analysis program would look like:</p><pre><code class="nohighlight hljs">using JuliaSyntax, SemanticAST

filename = &quot;hello_world.jl&quot;
source_tree = parsestmt(SyntaxNode, read(filename, String), filename=filename)
semantic_tree = expand_toplevel(source_tree)</code></pre><p>that&#39;s it!</p><h2 id="Limitation:-Macros"><a class="docs-heading-anchor" href="#Limitation:-Macros">Limitation: Macros</a><a id="Limitation:-Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Limitation:-Macros" title="Permalink"></a></h2><p>At present SemanticAST tries to cover much of &quot;basic&quot; Julia - but there&#39;s a major fly in the ointment: macros.</p><p>Macros are challenging for the SemanticAST approach because they can accept non-standard Julia <code>Expr</code>s and then both produce unusual <code>Expr</code> forms as well as use a wide range of forms not otherwise produced by parsing. As SemanticAST sits on top of JuliaSyntax and only understands JuliaSyntax <code>SyntaxNode</code>s it cannot practically run macros directly as while a <code>SyntaxNode</code> can be converted to an <code>Expr</code> vice versa is not possible without loss of information. Thus, at present, macro invocations are simply replaced with a placeholder. There&#39;s limited hardcoded support for a small list of built-in macros and an extension mechanism, but no more.</p><h2 id="Limitation:-Quoting"><a class="docs-heading-anchor" href="#Limitation:-Quoting">Limitation: Quoting</a><a id="Limitation:-Quoting-1"></a><a class="docs-heading-anchor-permalink" href="#Limitation:-Quoting" title="Permalink"></a></h2><p>While SemanticAST will not <em>choke</em> on quotes, it won&#39;t interpret them intelligently. Quotes are seen as a big blob of <code>Expr</code>, <em>including unquotes</em>.</p><h1 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h1><p>SemanticAST is part of the implementation of <a href="https://benchung.github.io/papers/thesis.pdf">my thesis on typing Julia</a> and its current implementation was designed specifically to fit the needs of a type system. As a result, it is missing a number of features that might be interesting. Two that I think would be interesting are:</p><ul><li>The ability to analyze normal <code>Exprs</code> and not only JuliaSyntax nodes. This could be accomplished by extending the custom patterns to support <code>Expr</code>s, and would allow SemanticAST to be used after macro expansion (or as part of normal Julia macro implementations) when combined with</li><li>Support for semantic forms that don&#39;t result from parsing. My goal was to support parser output but macros are allowed to use a larger <code>Expr</code> language. As a result, analyzing post-expansion <code>Expr</code>s is not possible.</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="interface/">Public interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 5 September 2023 05:42">Tuesday 5 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
